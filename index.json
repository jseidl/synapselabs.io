[{"categories":["Home Automation"],"contents":"My biggest personal challenge in home automation is a quest to make everyday commoner tasks \u0026ndash; such as turning on and off lights, fans, air conditioners and media devices \u0026ndash; a thing of the past. My ultimate intent is to just do whatever I want to do and for Skynet the house to figure it out what it is and act accordingly and when I\u0026rsquo;m done I can just walk away and things will turn off themselves. After a few years experimenting with all sorts of stuff, learning how to develop on Home Assistant, I finally came up with a custom component that replaced hundreds of lines of YAML and made me much closer to my goal.\n TL;DR: If you don\u0026rsquo;t care about the story nor my feelings and just wanna get on to how awesome Magic Areas is, click here.\n Background The remote-controlled house When I first started playing around with Home Assistant, I had only a couple of DIY Multisensors I\u0026rsquo;ve built, a few Philips Hue bulbs and that\u0026rsquo;s it. I would access Home Assistant\u0026rsquo;s UI over my phone\u0026rsquo;s browser and fool around turning lights on and off and changing colors. I believe this is the first stage everyone that starts messing around with smart homes goes through.\nDon\u0026rsquo;t get me wrong. Many people take pride on showing their Google Home/Homekit bullshit and how they can turn a bunch of proprietary stuff on and off, I pity you right on, bro! I\u0026rsquo;ve been writing bots and automations for many different processes all my life and for me, controlling things with my phone was cute but mostly a party trick. In my opinion, one cannot say something is smart if it relies on a 3rd party command to do shit perform actions.\nThis needed less human interaction. More machine \u0026ldquo;brains\u0026rdquo;. (No, I\u0026rsquo;m not talking about AI, yet)\nThe automatic house Frustrated with my medieval way of having to pull my phone off every now and then to control stuff, I quickly went on and through the power of Home Assistant\u0026rsquo;s automations, made the motion sensors in my DIY multisensors trigger the Hue bulbs, making them no better than those motion-activated lights on public restrooms.\nThat wasn\u0026rsquo;t enough. Even though it was a good improvement from having to manually flip light switches like a primate myself, I now had the problem which the lights would go out on me while I was in the room just because I was sitting still (like watching TV, looking at my phone in the bathroom or at the computer).\nThere was a lot of trial-and-error testing different clear timeouts on the automations so it wouldn\u0026rsquo;t shut the lights on us. Too little and they go off too often. Too much and you can\u0026rsquo;t just leave the room like a badass unless you\u0026rsquo;re willing to have lights just chomping electrons for no reason.\nAlso, suffice to say, my wife was NOT happy.\nAt first, there were few. Now, there are many My Hue kit came with 3 color bulbs, which I placed one in the Living Room, one in the Bedroom and one in our Home Office/Lab/Evil lair so I made 3 DIY multisensors. I had the same automations copy-pasted-and-adjusted for every room, triggering the bulbs when the motion sensors on the multisensors detected movement, turning them off when they\u0026rsquo;re idle for some minutes.\nAfter some while I got some white hue bulbs and some Z-Wave multisensors which I\u0026rsquo;ve put on my front door and on my patio, then as time went by I\u0026rsquo;ve got Z-Wave light switches, Z-Wave and Zigbee power outlets and went by smartifing other rooms in the condo I lived by that time, so there I was again copying and pasting all those automations over and over again.\nNot to mention that I started to get a taste for Z-wave/Zigbee and have battery-powered Z(wave|igbee) multisensors in addition to my DIY ones, so I could cover more angles and mitigate my long timeouts. I started first listing both of them on my automation triggers, then realized it was smarter to have a group, so I did that too for every room in the house. Then I did a template binary_sensor, based on the state of the group, with the occupancy device_class. This was my first effort on trying to maintain a room state.\nCan you imagine the pain it was when I wanted to change timeouts or the automations themselves? It was NOT FUN going through all those YAML files and replacing code. It started to get out of hand FAST, something needed to be done.\nSensor aggregation By having only one multisensor per room, I realized I was getting biased readings. Sensors on window frames would reflect more the outside temperature rather than the internal, due to being stuck into metal frames. Sensors near heat sources (TV, computer) would read temperatures hotter than the room itself.\nMy immediate solution was to have more than 1 multisensor in a room and average their results to get something closer to reality. Having several multisensors around the same area gives you the luxury of discarding data from some (like temperature from the ones in the metal frames) as well.\nOnce again, there I was furiously crafting YAML files for my min/max mean sensors for every room, for temperature, humidity, luminosity\u0026hellip; you get the gist.\nThe Problem What presence means? When I first started trying to solve room presence, I coined two terms: Global Presence and Local Presence. One is reliable (if you do it right) and straightforward. The other is almost an art form.\nGlobal Presence is the bread and butter of letting your smart home controller know that you\u0026rsquo;re at home or away. This is usually done by either (or a combination of) device_trackers with GPS and/or network presence and Bluetooth/BLE monitors.\nLocal Presence is the tricky part: letting the smart home controller know which room of your house you\u0026rsquo;re in. It creates the mental exercise of thinking: Which devices and which states they\u0026rsquo;re found that can be classified as the room being in use? After some experimenting, I\u0026rsquo;ve compiled the following list:\n Devices connected on the network Some devices aren\u0026rsquo;t always online and only connect to your network when you turn them on (e.g. some Smart TVs) Motion Sensors Well, obviously Media Players When on state playing. Usually when something is playing it means the room is being used. YMMV. Doors / Covers Some doors being open may be considered as a presence sensor. For example, when my front door is open it means my front_door and entrance_hall areas are occupied. For my garage, both the garage door (exposed as a cover to Home Assistant) and the door in the kitchen that goes to the garage being open mean that the garage area is occupied. Power consumption Metered smart outlets are the swiss-army knife of state detection for non-smart things. You can use it to detect operating state of devices that sleep (e.g. videogame consoles), cellphones charging, if the laptop is connected to my dock station, if you\u0026rsquo;re working out on a treadmill or stationary bike, etc. Weight measurement and Capacitive/Flex sensors If you\u0026rsquo;re a regular, you know how I use two bathroom scales to detect occupancy on my bed. The same could be made with capacitive or flex sensors. Leak sensors These can work to detect presence in bathrooms while you\u0026rsquo;re on the shower. The catch is that not all devices can work receiving a shower on its head and that depending on the placement they can take a while to clear.  So that\u0026rsquo;s my non-exhaustive list of presency things, I needed a way of tieing these together in order to determine the room state. I tried doing that with Home Assistant primitives at first, a bunch of template sensors and binary_sensors, two kilos of automations and the sacrifice of a goat but things were very janky and a pain to debug. I knew that I would need to start digging into the developer documentation and to write a custom_component that I could only pass configuration parameters such as the room name and the entity_ids and be done with it.\nManual override: The Presence Hold There are situations where you might not be able to sense presence (as sitting perfectly still reading a book) in which having a manual override for the room presence status is a must. I\u0026rsquo;ve accomplished this in the past by having a template \u0026lsquo;switch\u0026rsquo; in Home Assistant that I\u0026rsquo;d use as a condition on my automations. I called this functionality Presence Hold.\nMy first shot at implementing this in a component was a complete bust. Worked part of the time and wasn\u0026rsquo;t very reliable. The flaw wasn\u0026rsquo;t in the code per se, but the logic behind it was completely flawed, which I\u0026rsquo;ll go more in depth in our next section below.\nFirst shot a custom_components, the Room component After much grief juggling dozens of automation YAML files, I decided to put on my big boi pants and read Home Assistant\u0026rsquo;s developer documentation, which is pretty decent for the most part. I started by dissecting one of the custom components I had already running and checking the APIs in the docs. It\u0026rsquo;s all Python, pretty much straightforward.\nThis first component, which I called HA Room was my first shot at it. It creates a single occupancy binary_sensor for each area defined in the YAML config that tracks the state of the defined presence_sensors and updates the room occupancy state accordingly. This is a very simple component that does that one task almost very well.\nIt would be perfect for this single case, if I didn\u0026rsquo;t had screwed up completely the presence hold logic. My idea/logic for this on this component was to have some entities vouch for the presence hold status (like presence on by Bed Sensor) whose states would be tracked by a Presence Hold switch that tracks in order to determine if presence_hold behavior should be enforced. The room presence binary_sensor would check the presence hold status before proceeding with any status change.\nThis switch could be manually triggered but as you can imagine, a presence_hold_sensor could go to off turning that switch back off, which was annoying as fuck. Also I had to implement a timed function to update the binary_sensor status, because if all the presence_sensors were off by the time you turned presence hold off, you\u0026rsquo;d be stuck on that on state until you flipped the room state on and off again. Nightmare.\nPresence Hold would work when I had entities who could vouch for the presence hold state but if you wanted to use it as a manual override it was shit disappointing.\nI wasn\u0026rsquo;t super happy about this component, although it was a HUGE change from having to maintain several automations. I did a small release on the community forums, but that was it. I knew I need to completely revisit this component and make it into something more substantial.\nBy that time, Home Assistant was releasing their Area Registry which is still to date not very useful (well, helps on telling your Google Assistant where things are but that\u0026rsquo;s pretty much it). I had a vision on how I thought areas should behave in a smart home since I\u0026rsquo;ve been replicating the same functionalities across several rooms and recently decided to give it another shot.\nMastering local presence with Magic Areas After HA Room I had many open questions such as: How can I use Area Registry in this solution? Why also not give the ability of add non-registry-enabled entities like template entities and non-discovery mqtt entities? Why not build my most common automations into the component? Why not make every single behavior configurable? Why not go further than area presence and also go ahead and auto-discover sensor device_class and aggregate them automatically?\nMagic Areas was born to address all those questions.\nFeatures  Uses multiple type of sensors for determining presence on an area.  media_player, binary_sensors (motion, presence, occupancy and door) are supported.   Loads areas from Area Registry \u0026ndash; No need of handling them elsewhere!. Support inclusion of non-device-tied entities (non-discovery MQTT/Template sensors). Support exclusion of entities. Automatic turn climates and lights on! (All or user-defined).  Specify a disable_entity for when lights shouldn\u0026rsquo;t turn on (e.g. daytime, high luminance etc) Specify a sleep_entity and sleep_lights to have only your accent lights turn on late at night   Automatic turn off lights, climate and media devices. Creates a Health sensor (triggered by binary_sensors with problem, smoke, moisture, safety and gas device classes) for each area Creates a Presence Hold switch to manually override area presence Creates aggregation sensors for your binary_sensor:  Motion sensors Door sensors Window sensors Leak sensors   Creates average sensors for all your sensor Creates global (interior/exterior) aggregate and average sensors  A quick video of some of these features in action can be seen on this tweet I\u0026rsquo;ve sent while I was developing it: This is working great so far. pic.twitter.com/DQtcaYyE36\n\u0026mdash; Jan Seidl (@jseidl) September 27, 2020  Functionalities If you run Magic Areas by default, all options will be enabled. Magic Areas will scan the Areas defined in your registry, go through the devices on those areas and chomp all the entities there.\nArea Presence You will have one binary_sensor for each room for tracking the area presence and a manual override presence_hold switch (that only does that, with no crazy flawed logic this time).\nOne of the big advantages from HA Room is that I\u0026rsquo;ve took the time to add an active_sensors attribute so you can always see which sensors are keeping the state on for debugging purposes. This practice is applied all around through the aggregation sensors you\u0026rsquo;ll see next.\nManaging entities All entities are pulled from the registry by default. If you did your homework and assigned your devices to areas, you should be done, save a really tricky exception: Standalone entities (entities not tied to a device) such as template entities and non-discovery mqtt entities are not tied to a device thus can never exist in the Area Registry since this registry only accept devices, not entities. These (if they have a unique_id set) can go to the Entity Registry which makes our lives easier but not by that much.\nThis component enables the inclusion of standalone entities over the include_entities configuration parameter.\nYou might also have entities in your registry that you (for any particular reason) might not want to be controlled/tracked by Magic Areas and you can easily exclude them over the exclude_entities configuration parameter.\nEntity type auto-discovery In Magic Areas you don\u0026rsquo;t have to tell it much. Just define your entities and the component will probe it\u0026rsquo;s domain (light, climate etc) and device_class (if it\u0026rsquo;s a sensor/binary_sensor) and handle them accordingly. Isn\u0026rsquo;t it a beaut?\nArea sensor/binary_sensor aggregates Magic Areas will create one aggregate sensor and binary_sensor for each device_class in that area. sensor aggregates use a mean approach for aggregation while binary_sensor aggregates are on if any of the aggregated sensors' state is on.\nArea Health sensors If you have any safety-related sensors such as smoke/CO, tamper or leak (from problem, smoke, moisture, safety and gas device classes in an area, Magic Areas will create a health sensor for this area that will turn on whenever one of the related safety sensors is triggered.\nThis is a cool feature if you keep one of those cool picture-elements floorplans and wanna point out which area in specific is in distress.\nNote: There\u0026rsquo;s a planned feature to have a global health sensor for the whole house that tracks each area\u0026rsquo;s health sensors. Keep an eye on this GitHub issue for news on that feature!\nInternal / External area aggregates For each Area, you are able to define the external configuration parameter, allowing you to distinguish between internal and external areas (such as Front Door or Backyard) and Magic Areas will generate aggregate sensor and binary_sensor for each device_class present and aggregate values from all areas together (all internal in one aggregate, all external in another aggregate).\nAutomatic on-off switching Magic Areas will automatically turn off all light, climate and media_player entities in that area when presence is changed to off. This ensures you\u0026rsquo;ll never let anything running when the room is not being used.\nClimates will be turned on when the area presence state is switched to on. This feature is interesting because you can create Generic Thermostats to turn fans on/off based off the temperature of that area, thus relying the automation of turning the actual climate device on/off to the thermostat if the temperature setpoint is met.\nLight orchestration is a little more sophisticated, following the steps of the Circadian Lighting component, light automations follow other constraints:\n If the room is in a sleep state: Defined by sleep_entity and sleep_state parameters If the room is in a disable state: Defined by disable_entity and disable_state parameters  On sleep state, Magic Areas will only turn on the lights defined in sleep_entities. On disable state, Magic Areas won\u0026rsquo;t turn any lights on, but will still turn them off if the area presence state goes to off.\nThis design choice makes it a perfect pair for light-controlling components like Flux, Circadian Lighting and Adaptive Lighting. You\u0026rsquo;ll walk around like a fucking god king and your path will light in front of you.\nInstallation Manual Installation You can download the zip file from the GitHub repository, add the custom_components/magic_areas folder into your config/custom_components folder.\nHACS Install Magic Areas isn\u0026rsquo;t yet in the main HACS repository but you can add the GitHub repository to HACS as a custom repository by going to HACS \u0026gt; Settings \u0026gt; Custom Repositories and adding the repo\u0026rsquo;s URL.\nConfiguration For a basic setup, just add the following to your configuration.yaml or in a package:\nmagic_areas:\rYou can check out the full configuration parameters with description and defaults at the GitHub repository.\nConclusion This has been a fun journey and it\u0026rsquo;s far from complete. I intend on polishing Magic Areas and adding new features. Make sure to follow me on Twitter, star the repository on GitHub, add the repository to HACS and start testing out today!\nREMEMBER: Magic Areas doesn\u0026rsquo;t do miracles! Its performance is totally dependent on your sensors and their placement, it only automates stuff that you\u0026rsquo;d have to manually create and maintain.\nLet me know what are your thoughts on this component on the comments below. If you have any questions or feature requests, use the GitHub Issues page of the repository to reach out to me.\n","permalink":"https://synapselabs.io/posts/bring-home-assistant-area-to-life-with-magic-areas/","tags":["Home Assistant","Custom Component","Automation"],"title":"Master local presence and bring Home Assistant's areas to life with Magic Areas"},{"categories":["Home Automation"],"contents":"Having a sweet electric car is sweet indeed. But integrating it with your home automation system, that\u0026rsquo;s even sweeter! Fortunately Home Assistant has a native integration through Tesla\u0026rsquo;s cloud and with some Lovelace magic we can make the most out of it on our Dashboards.\nSo you got your new sweet ass new Tesla and sure you could use the integrations with Google Assistant, Alexa or Homekit like a peasant but we\u0026rsquo;re DIY-ers and that doesn\u0026rsquo;t cut.\nAdding the integration The Tesla integration is available on vanilla Home Assistant. You can either go through the UI or go with the YAML route (I prefer to have my configuration as code whenever possible).\nFor the yaml configuration, I\u0026rsquo;ve created a new file under my packages folder called tesla.yaml with the following contents. We\u0026rsquo;ll be doing the basic configuration (credentials) and a little additional configuration such as bumping up the scan_interval to 15 minutes (300 seconds) to save on the car\u0026rsquo;s battery and some customization to get the names right for the cards:\nhomeassistant: customize_glob: \u0026#39;lock.tesla_*_door_lock\u0026#39;: friendly_name: Doors \u0026#39;lock.tesla_*_charger_door_lock\u0026#39;: friendly_name: Charger Door \u0026#39;lock.tesla_*_frunk_lock\u0026#39;: friendly_name: Frunk \u0026#39;lock.tesla_*_trunk_lock\u0026#39;: friendly_name: Trunk \u0026#39;binary_sensor.tesla_*_parking_brake_sensor\u0026#39;: friendly_name: Parking Brake tesla: username: !secret tesla_email_address password: !secret tesla_password scan_interval: 900 # 15 min You have to add the corresponding entries on your secrets.yaml file\nRestart Home Assistant and this will add a bunch of sensors (and switches) related to your Tesla car.\nGetting the picture of your Tesla That\u0026rsquo;s pretty easy, go into your Tesla account, select Manage on your car, right click the image and save the PNG somewhere into your www folder. I\u0026rsquo;ve saved mine to www/images/other/tesla.png.\nCreating the lovelace card Sure you can view your car\u0026rsquo;s status through the official Tesla app, but that\u0026rsquo;s something that every other Tesla owner can and that\u0026rsquo;s no fun. We wanna be better than them be different. We want to view and control all of our stuff in one place and rub into other people\u0026rsquo;s faces.\nI wanted to have a card with all the important data on it so I can add to my \u0026ldquo;Console\u0026rdquo; view. I\u0026rsquo;ve used the Picture Elements card for many different projects so I knew it would fit me well on this case. I went on creating a cards/tesla.yaml file that I will later on !include on my views.\nI\u0026rsquo;ve separated my sensors into quarters (upper left, upper right, lower left, lower right) and divided my sensors into four different lists/arrays using jinja2. I\u0026rsquo;ve made tuple of (title, sensor) for each sensor I wanted on my card.\nI\u0026rsquo;ve grouped the sensors into four categories: General, Locks, Battery/Charge-related and Temperature. I\u0026rsquo;ve added them as tuples where mostly is (title, entity) except the first one that is (entity, show_friendly_name_instead_of_state).\n{% set sensors = [ (\u0026#39;binary_sensor.tesla_model_3_online_sensor\u0026#39;, False), (\u0026#39;binary_sensor.tesla_model_3_parking_brake_sensor\u0026#39;, True), (\u0026#39;climate.tesla_model_3_hvac_climate_system\u0026#39;, False), (\u0026#39;device_tracker.tesla_model_3_location_tracker\u0026#39;, False), (\u0026#39;sensor.tesla_model_3_mileage_sensor\u0026#39;, False) ] %} {% set lock_sensors = [ (\u0026#39;Charger door\u0026#39;, \u0026#39;lock.tesla_model_3_charger_door_lock\u0026#39;), (\u0026#39;Doors\u0026#39;, \u0026#39;lock.tesla_model_3_door_lock\u0026#39;), (\u0026#39;Frunk\u0026#39;, \u0026#39;lock.tesla_model_3_frunk_lock\u0026#39;), (\u0026#39;Trunk\u0026#39;,\u0026#39;lock.tesla_model_3_trunk_lock\u0026#39;) ] %} {% set battery_sensors = [ (\u0026#39;Battery\u0026#39;, \u0026#39;sensor.tesla_model_3_battery_sensor\u0026#39;), (\u0026#39;Charging\u0026#39;, \u0026#39;binary_sensor.tesla_model_3_charger_sensor\u0026#39;), (\u0026#39;Range\u0026#39;, \u0026#39;sensor.tesla_model_3_range_sensor\u0026#39;) ] %} {% set temp_sensors = [ (\u0026#39;Inside\u0026#39;, \u0026#39;sensor.tesla_model_3_temperature_sensor_inside\u0026#39;), (\u0026#39;Outside\u0026#39; ,\u0026#39;sensor.tesla_model_3_temperature_sensor_outside\u0026#39;) ] %} Since we already have the PNG image and the sensors we want to track, let\u0026rsquo;s get the card started:\ntype: picture-elements image: !file /local/images/other/tesla.png elements: Then still using jinja2 I used the for loops to print out the sensors' icons and state :\n{% for g in sensors %} - type: state-icon entity: {{ g.0 }} style: right: 0 top: 5px margin-top: {{ loop.index0*32 }}px transform: initial font-size: 1em line-height: 2em \u0026#34;--paper-item-icon-color\u0026#34;: white - type: state-label entity: {{ g.0 }} {% if g.1 %}attribute: \u0026#39;friendly_name\u0026#39;{% endif %} style: transform: initial font-size: 1em line-height: 2em top: 5px right: 30px margin-top: {{ loop.index0*32 }}px {% endfor -%} {% for g in lock_sensors %} - type: state-icon entity: {{ g.1 }} style: left: 0 top: 5px margin-top: {{ loop.index0*32 }}px transform: initial font-size: 1em line-height: 2em \u0026#34;--paper-item-icon-color\u0026#34;: white - type: state-label entity: {{ g.1 }} title: {{ g.0 }} attribute: \u0026#39;friendly_name\u0026#39; style: transform: initial font-size: 1em line-height: 2em top: 5px left: 30px margin-top: {{ loop.index0*32 }}px {% endfor -%} {% for g in battery_sensors %} - type: state-icon entity: {{ g.1 }} style: left: 0 bottom: 10px margin-bottom: {{ loop.index0*32 }}px transform: initial font-size: 1em line-height: 2em \u0026#34;--paper-item-icon-color\u0026#34;: white - type: state-label entity: {{ g.1 }} title: {{ g.0 }} prefix: \u0026#34;{{ g.0 }}: \u0026#34; style: transform: initial font-size: 1em line-height: 2em bottom: 5px left: 30px margin-bottom: {{ loop.index0*32 }}px {% endfor -%} {% for g in temp_sensors %} - type: state-icon entity: {{ g.1 }} style: right: 0 bottom: 10px margin-bottom: {{ loop.index0*32 }}px transform: initial font-size: 1em line-height: 2em \u0026#34;--paper-item-icon-color\u0026#34;: white - type: state-label entity: {{ g.1 }} title: {{ g.0 }} prefix: \u0026#34;{{ g.0 }}: \u0026#34; style: transform: initial font-size: 1em line-height: 2em bottom: 5px right: 30px margin-bottom: {{ loop.index0*32 }}px {% endfor -%} This will go through all your sensors and plot them in the four corners. If you want to customize them, use the Customize settings and it should react accordingly!\nYou can check out the full code for the card here.\nCreating the Tesla Lovelace view A few days after having the card on my main view, I decided I wanted to have also a dedicated view for the car information, also control the AC and all other nifty Locks and Switches. Also, graphs, just because.\nI used pretty much standard cards, except for the Bar Card for the progress bars and Simple Thermostat for the A/C control.\n Temperature graphs and A/C control (Simple Thermostat - Add-on) Battery \u0026amp; Range graphs + progress bars (Graph card + Bar Card) Map showing the car\u0026rsquo;s location (Map card - Built-in) All locks (Entities card) All switches (Entities card)  You can check out the full code for the view here.\nAnd that\u0026rsquo;s it, you have all your sweet Tesla\u0026rsquo;s information and control on your centralized system instead of having one more app to deal with. Next time some Tesla owner pulls up their Tesla app next to you, you can disrespectfully laugh in disgust and pity, possibly spittitng in the floor next to them open up Home Assistant and feel the glory of your labor.\nDo you have any other cool ideas on UI or automations for the Tesla? Let me know in the comments!\n","permalink":"https://synapselabs.io/posts/integrating-your-tesla-with-home-assistant/","tags":["Home Assistant","Tesla","Lovelace"],"title":"Integrating your Tesla with Home Assistant"},{"categories":["Home Automation"],"contents":"Shortly after I released my latest post, a friend DM\u0026rsquo;ed me on Twitter and asked about my residents card that I showcased briefly, so it gave the perfect opportunity on making a post about it and share with the world this card that I enjoy so much. It\u0026rsquo;s pretty easy and it\u0026rsquo;s mostly vanilla Home Assistant/Lovelace so put your mad scientist lab coats, hop aboard and let\u0026rsquo;s learn how to make awesome display cards.\nThe idea of developing a residents card came from seeing many other Home Assistant\u0026rsquo;s user\u0026rsquo;s designs around the web, many included their device_tracker status, name and picture and I wanted to give a little more spice to it.\nUploading your resident\u0026rsquo;s images and creating the person entities If you don\u0026rsquo;t have your person entries yet, let\u0026rsquo;s start with the basic. I usually have a person folder under packages. If you\u0026rsquo;re not using packages and still have all your configuration under configuration.yaml with over 600 lines like a savage literally from before fire was discovered, stop what you\u0026rsquo;re doing right now and go convert into the packages model.\nOr\u0026hellip; well\u0026hellip;. you can wait until I write about it too. Shame is already there patting you in the back anyway.\nI create one file per resident where I define the customize entry (resident picture), the person entity with only one device_tracker entry, because I use the Better Presence add-on (we\u0026rsquo;ll see more about presence detection and this add-on in a future post).\n# jseidl.yaml homeassistant: customize: person.jan: entity_picture: \u0026#34;/local/images/residents/jseidl.jpg\u0026#34; person: - name: Jan id: jseidl user_id: !secret person_jseidl_userid device_trackers: - device_tracker.jseidl_presence Creating proximity sensors Upon randomly reading Home Assistant\u0026rsquo;s components documentation, I\u0026rsquo;ve stumbled uponn the proximity sensor and decided it would be a cool addition to my residents information. For that to work, you\u0026rsquo;ll need device_tracker entries with GPS info, so I add our phones (OwnTracks) device_tracker entity exclusively since my aggregate one not always have GPS info on it.\nproximity: home_jseidl: devices: - device_tracker.jseidl_phone tolerance: 50 unit_of_measurement: mi home_wife: devices: - device_tracker.wife_phone tolerance: 50 unit_of_measurement: mi home_residents: devices: - device_tracker.wife_phone - device_tracker.jseidl_phone tolerance: 50 unit_of_measurement: mi This sensor not only gives you the distance between the resident and home but also if the resident is moving towards or away from home. You can calculate the distance to zones other than home by changing the zone attribute of the sensor (defaults to home).\nThis is specially useful to check if you can play one more round of your favorite video-game before your partner arrives and give you heat for being playing video-games all day for many different reasons.\nCreating battery_level sensors if your battery_level is a sensor\u0026rsquo;s attribute Many sensors will have a battery_level attribute but that won\u0026rsquo;t work with Picture Elements card that we\u0026rsquo;ll be using to build up our residents card. Its state-icon entry needs an entity icon. You will need a sensor entity exclusively for this value with an battery icon.\nIf you don\u0026rsquo;t have one yet you can hop back into my latest post to find out how to make cool dynamic icon for your cell phone battery level.\nCreating the card definition Each resident block consists of a picture, the zone indicator (Home/Away/Work) and the distance to home in the bottom and the phone battery percentage and icon on the top left corner.\nI use a small CSS trick to make the Zone Indicator element span across all bottom part forming a bar with a black background with 0.4 opacity for the looks. Positioning is done using percentages and em so all is relative and somewhat responsive.\ncards: - type: picture-elements image: !file /local/images/residents/jseidl.jpg elements: # Home / Away - Zone indicator - type: state-label entity: device_tracker.jseidl_presence style: left: 0 bottom: 0 pointer-events: none line-height: 1.1em font-size: 1.1em background-color: rgba(0, 0, 0, 0.4) width: 100% transform: initial padding: 0 2px # Proximity to Home - type: state-label entity: proximity.home_jseidl style: right: 0 bottom: 0 pointer-events: none transform: initial line-height: 1.1em font-size: 1.1em padding: 0 2px \u0026#34;--paper-item-icon-color\u0026#34;: white # Phone Battery (Text) - type: state-label entity: sensor.jseidl_phone_batt title: sensor.jseidl_phone_batt style: left: 0 top: 0 padding: 0 8px pointer-events: none transform: initial line-height: 2em font-size: 1.1em # Phone Battery (Icon) - type: state-icon entity: sensor.jseidl_phone_batt style: right: 0 top: 2% pointer-events: none transform: initial line-height: 2em font-size: 1.1em \u0026#34;--paper-item-icon-color\u0026#34;: white And that\u0026rsquo;s all it takes to have a nice residents display on your Lovelace UI. Picture Elements is very powerful and I use in quite different cards that I will be showcasing in a near future. Let me know in the comments what other information do you think it would be useful to have in this card. Stay safe and keep getting creative with your homes!\n","permalink":"https://synapselabs.io/posts/lovelace-residents-card-for-home-assistant/","tags":["Home Assistant","Lovelace"],"title":"Create a custom 'Residents' card in your Home Assistant's dashboard"},{"categories":["Home Automation"],"contents":"There are several components in Home Assistant that report their battery level. Today we\u0026rsquo;re gonna learn how to do some cool tricks in order to get most of this information such as :\n Notifying Low battery sensors Grouping multiple battery sensors for the same device Getting your phone\u0026rsquo;s charging state by monitoring the battery level Reminder for charging your phone Tweaking the battery icon with charging states  Low battery sensors I have a bunch of wireless Zigbee and Z-Wave sensors integrated with Home Assistant. Even thou they\u0026rsquo;re very efficient by using deep sleep, I still have to change their battery from time to time and I\u0026rsquo;d rather be notified that I need to do so than one day realize something is not working because that sensor\u0026rsquo;s battery is dead.\nI\u0026rsquo;m pretty familiar with Jinja2 (Home Assistant\u0026rsquo;s Templating language) from years of developing Flask apps so I decided to give a try on creating this sensor with Home Assistant\u0026rsquo;s Template sensor with filters to beautifully achieve its goal.\nI ended up using a Template sensor to get the lowest battery level across all sensors, then a Template binary_sensor with a problem device_class to indicate wether a sensor has low battery (if the lowest battery level is below a certain threshold) and a alert to keep notifying me in a given interval until I charge or replace the battery. I also used a list to keep the sensors I want to ignore like our phone\u0026rsquo;s battery.\nsensor: - platform: template sensors: sensors_lowest_battery_level: friendly_name: \u0026#39;Lowest battery level (Sensors)\u0026#39; entity_id: sun.sun device_class: battery unit_of_measurement: \u0026#39;%\u0026#39; value_template: \u0026gt;{% set domains = [\u0026#39;sensor\u0026#39;, \u0026#39;zwave\u0026#39;] %} {% set ns = namespace(min_batt=100, entities=[]) %} {%- set exclude_sensors = [\u0026#39;sensor.sensors_lowest_battery_level\u0026#39;,\u0026#39;sensor.wife_phone_batt\u0026#39;,\u0026#39;sensor.jseidl_phone_batt\u0026#39;] -%} {% for domain in domains %} {% set ns.entities = states[domain] %} {% for sensor in exclude_sensors %} {% set ns.entities = ns.entities | rejectattr(\u0026#39;entity_id\u0026#39;, \u0026#39;equalto\u0026#39;, sensor) %} {% endfor %} {% set batt_sensors = ns.entities | selectattr(\u0026#39;attributes.device_class\u0026#39;,\u0026#39;equalto\u0026#39;,\u0026#39;battery\u0026#39;) | map(attribute=\u0026#39;state\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, \u0026#39;unknown\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, \u0026#39;None\u0026#39;) | map(\u0026#39;int\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, 0) | list %} {% set batt_attrs = ns.entities | selectattr(\u0026#39;attributes.battery_level\u0026#39;,\u0026#39;defined\u0026#39;) | map(attribute=\u0026#39;attributes.battery_level\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, \u0026#39;unknown\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, \u0026#39;None\u0026#39;) | map(\u0026#39;int\u0026#39;) | reject(\u0026#39;equalto\u0026#39;, 0) | list %} {% set batt_lvls = batt_sensors + batt_attrs %} {% if batt_lvls|length \u0026gt; 0 %} {% set _min = batt_lvls|min %} {% if _min \u0026lt; ns.min_batt %} {% set ns.min_batt = _min %} {% endif %} {% endif %} {% endfor %} {{ ns.min_batt }} binary_sensor: - platform: template sensors: sensor_low_battery: value_template: \u0026#34;{{ states(\u0026#39;sensor.sensors_lowest_battery_level\u0026#39;)|int \u0026lt;= 40 }}\u0026#34; friendly_name: \u0026#39;A sensor has low battery\u0026#39; device_class: problem alert: sensor_low_battery: name: Sensor has low battery! message: \u0026gt;{%- set domains = [\u0026#39;sensor\u0026#39;, \u0026#39;zwave\u0026#39;] -%} {%- set threshold = 40 -%} {%- set exclude_entities = [\u0026#39;sensor.sensors_lowest_battery_level\u0026#39;,\u0026#39;sensor.wife_phone_batt\u0026#39;,\u0026#39;sensor.jseidl_phone_batt\u0026#39;] -%} Sensors are below 40% battery: {%- for domain in domains -%} {%- for item in states[domain] -%} {%- if item.entity_id not in exclude_entities -%} {%- if item.attributes.battery_level is defined -%} {%- set level = item.attributes.battery_level|int -%} {% if level \u0026gt; 0 and level \u0026lt; threshold %} - {{ item.attributes.friendly_name }} ({{ item.attributes[\u0026#39;battery_level\u0026#39;]|int}}%) {%- endif -%} {%- endif -%} {%- if item.attributes.device_class is defined and item.attributes.device_class == \u0026#39;battery\u0026#39; -%} {%- set level = item.state|int -%} {% if level \u0026gt; 0 and level \u0026lt;= threshold %} - {{ item.attributes.friendly_name }} ({{ item.state|int }}%) {%- endif -%} {%- endif %} {%- endif -%} {%- endfor -%} {%- endfor -%} entity_id: binary_sensor.sensor_low_battery state: \u0026#39;on\u0026#39; repeat: - 5 - 60 - 360 skip_first: true can_acknowledge: true notifiers: - jseidl_telegram Grouping multiple battery sensors for the same device At our home we use both OwnTracks and the Home Assistant app for Android that report battery_level. This is one easy trick that I also use for my multisensors to get a room average of temperature, luminosity, humidity etc by averaging all sensors in that room. For that we\u0026rsquo;ll use the Min/Max sensor and Template sensor.\nsensor: - platform: template sensors: jseidl_phone_batt_owntracks: friendly_name: \u0026#34;Battery Level (Jan\u0026#39;s Phone - Owntracks)\u0026#34; unit_of_measurement: \u0026#39;%\u0026#39; device_class: battery value_template: \u0026#34;{{ state_attr(\u0026#39;device_tracker.jseidl_phone\u0026#39;, \u0026#39;battery_level\u0026#39;) }}\u0026#34; jseidl_phone_batt_ha_app: friendly_name: \u0026#34;Battery Level (Jan\u0026#39;s Phone - HA App)\u0026#34; unit_of_measurement: \u0026#39;%\u0026#39; device_class: battery value_template: \u0026#34;{{ state_attr(\u0026#39;device_tracker.jseidl_oneplus\u0026#39;, \u0026#39;battery_level\u0026#39;) }}\u0026#34; - platform: min_max type: mean entity_ids: - sensor.jseidl_phone_batt_owntracks - sensor.jseidl_phone_batt_ha_app Getting your phone\u0026rsquo;s charging state by monitoring the battery level Both device_tracker entities for our phones report only the battery_level but not the charging state. In order to get that information without any additional software running on the phones, I\u0026rsquo;ve decided to use the Trend sensor to decided if the phone is charging or discharging by observing the battery_level change across time.\n- platform: trend sensors: jseidl_phone_charging: entity_id: sensor.jseidl_phone_batt device_class: plug jseidl_phone_discharging: entity_id: sensor.jseidl_phone_batt invert: true device_class: battery Reminder for charging your phone Something that used to happen a lot with both my wife and I was waking up in the morning and realize you have 15% battery because we forgot to connect our phone to the charger.\nBy using the trend sensor trick from above plus my custom Bed sensor with ESPHome, we can cook up a quick automation to warn us with we ever commit that sin again. Note that I\u0026rsquo;m using my discharging sensor rather than the charging one because once the battery gets to 100% it will not be considered charging anymore.\nHere I\u0026rsquo;m using Google Assistant to announce it but you could use Alexa, send a Telegram message or just blink the lights.\nautomation: - alias: \u0026#39;Alert if in bed and phone not charging (Jan Side)\u0026#39; trigger: - platform: state entity_id: binary_sensor.bed_occupancy_right to: \u0026#39;on\u0026#39; for: minutes: 15 condition: - condition: state entity_id: input_boolean.bed_actions state: \u0026#39;on\u0026#39; - condition: state entity_id: binary_sensor.light_exterior state: \u0026#39;off\u0026#39; - condition: state entity_id: input_boolean.voice_notifications state: \u0026#39;on\u0026#39; - condition: state entity_id: binary_sensor.lfuentes_phone_discharging state: \u0026#39;on\u0026#39; action: - service: tts.google_translate_say entity_id: media_player.bedroom_speaker data: message: Don\u0026#39;t forget to connect your phone to the charger, Jan! The for 15 minutes statement is to give the trend sensor time to observe the changing data and set up correctly.\nTweaking the battery icon with charging states I wanted to use the charging states acquired from the trick above in my \u0026ldquo;residents\u0026rdquo; block on Lovelace UI. At first I had just added a charging state icon to the side of the main phone battery icon but that just didn\u0026rsquo;t looked good at all.\nI had created Template sensors to extract the battery_level attribute from my phone\u0026rsquo;s device_tracker entity from OwnTracks. It was easy to merge the charging state into a icon_template in that sensor\u0026rsquo;s definition thanks to Material Design Icons' naming convention (battery-90, battery-charing-90 etc).\nsensor: - platform: template sensors: jseidl_phone_batt: friendly_name: Phone Battery (Jan) device_class: Battery unit_of_measurement: \u0026#39;%\u0026#39; value_template: \u0026#34;{{ state_attr(\u0026#39;device_tracker.jseidl_presence\u0026#39;, \u0026#39;battery_level\u0026#39;) }}\u0026#34; icon_template: \u0026gt;-{% set tenths = state_attr(\u0026#39;device_tracker.jseidl_presence\u0026#39;, \u0026#39;battery_level\u0026#39;) / 10 %} {% set numeral = 10 * tenths|int %} mdi:battery{% if is_state(\u0026#39;binary_sensor.jseidl_phone_charging\u0026#39;, \u0026#39;on\u0026#39;) %}-charging{% endif %}{% if 10 \u0026lt;= numeral \u0026lt; 100 %}-{{ numeral }}{% elif numeral \u0026lt; 10 %}-outline{% endif %} Now the battery level icon will change between its regular or charging variant according to the phone\u0026rsquo;s charging state! Note that charging state is not the same as plugged in. We infer charging state by how the battery_level changes (increases or reduces) thus when the battery gets to 100% it will not show as charging even thou its plugged in.\nAnd that concludes all the tricks I know so far for battery_level. Template sensors are a VERY powerful tool. I use it a lot for solving various needs. What are your creative solutions with template sensors? Leave it down in the comments!\n","permalink":"https://synapselabs.io/posts/battery-level-tricks-with-home-assistant/","tags":["Home Assistant","Sensors"],"title":"Battery level tricks with Home assistant"},{"categories":["Home Automation"],"contents":"After slapping around multiple ESPHome-based multisensors around the house, I needed a way to keep them from going off while I\u0026rsquo;m sleeping and I wasn\u0026rsquo;t quite fond of manually disabling and re-enabling the automations in a daily basis. In order to get Home Assistant to know when myself or my wife are in bed, I\u0026rsquo;ve decided to create custom bed occupancy sensors using a pair of bathroom scales, a pair of HX711 load-cell sensors on top of the same framework (ESPHome).\nWhat you\u0026rsquo;re gonna need  ESP32 micro-controller Two HX711 load-cell sensor Some short dupont-cables Optional: 4-conductor (RJ11) telephone cable + dual line RJ11 keystone box  Wiring it up Usually the boards on the bathroom scales have already labeled the S+, S-, E+, E- pads. Just solder those pads to the respective pads on the HX711 and in the other end, connect V, GND, DOUT and CLK to the ESP32. I\u0026rsquo;ve used short cables to wire the bathroom scale side to the HX711 and house the IC inside the bathroom scale cover, drilled a hole to pass the cables through and used a 4-conductor telephone cable and a two-line keystone box to connect the HX711 to the ESP32 (the cable between the keystone box and the ESP32 is a regular ethernet cable because it has all 8 conductors needed).\nBathroom scale board \u0026amp; drilled enclosure.\nFrom left to right: Assembled, HX711 wiring, RJ11 keystone terminals on an ethernet cable, wiring on ESP32 end.\nSetting up the sensor in ESPHome is really easy:\nsensor: - platform: hx711 name: \u0026#34;Bed Weight (L)\u0026#34; id: bed_weight_l dout_pin: 12 clk_pin: 14 We\u0026rsquo;ll be calibrating and adding filtering to this sensor next.\nCalibrating the HX711 sensors Out of the box the numbers spat out by the HX711 means nothing much. In order to calibrate you start by taking note of the values when there is no-load (or just the expected normal load \u0026ndash; the mattress and bed sheets in this case) and you will need to do the same with at least one known-weight load (thus more is better) on top of your scale and take note of the numbers shown, average them and use in the calibrate_linear filter on ESPHome.\nI had my full clothes hamper at hand so I weighted myself holding it in a regular bathroom scale, then weighted myself alone and subtracted both weights to get the weight of the clothes hamper (5.6kg \u0026ndash; I know, not freedom units), then used it as a known-weight to calibrate my bed sensor. I also used my faithful sliding_window_moving_average filter to iron out erroneous readings and help false-negatives while changing sleep positions at night.\nfilters: - calibrate_linear: - 66000 -\u0026gt; 0 - 145000 -\u0026gt; 5.6 - sliding_window_moving_average: window_size: 5 send_every: 5 Watch out about WiFi powersave On ESPHome, the default setting for power_save_mode under wifi for ESP32s is LIGHT and that will make your sensor go unavailable from time to time due the ESP32 disconnecting from WiFi in order to save power. Make sure to change it to none to have it available all the time (we\u0026rsquo;re running constant power through USB so no worries there).\nwifi: ssid: \u0026#34;Your Wifi SSID\u0026#34; password: !secret wifi_password power_save_mode: none Full code\nesphome: name: meistersensor_bedsensor platform: ESP32 board: nodemcu-32s wifi: ssid: \u0026#34;Your Wifi SSID\u0026#34; password: !secret wifi_password power_save_mode: none # Enable logging logger: # Enable Home Assistant API api: password: !secret api_ota_password ota: password: !secret api_ota_password sensor: - platform: hx711 name: \u0026#34;Bed Weight (L)\u0026#34; id: bed_weight_l dout_pin: 12 clk_pin: 14 filters: - calibrate_linear: - 66000 -\u0026gt; 0 - 145000 -\u0026gt; 5.6 - sliding_window_moving_average: window_size: 5 send_every: 5 update_interval: 2s unit_of_measurement: kg accuracy_decimals: 2 - platform: hx711 name: \u0026#34;Bed Weight (R)\u0026#34; id: bed_weight_r dout_pin: 19 clk_pin: 18 filters: - calibrate_linear: - 435000 -\u0026gt; 0 - 512000 -\u0026gt; 5.6 - sliding_window_moving_average: window_size: 5 send_every: 5 update_interval: 2s unit_of_measurement: kg accuracy_decimals: 2 binary_sensor: - platform: template name: \u0026#34;Bed Occupancy (Left)\u0026#34; device_class: occupancy lambda: |-if (id(bed_weight_l).state \u0026gt; 10) { return true; } else { return false; } - platform: template name: \u0026#34;Bed Occupancy (Right)\u0026#34; device_class: occupancy lambda: |-if (id(bed_weight_r).state \u0026gt; 10) { return true; } else { return false; } Creating groups for the bed occupancy Groups are useful for a bunch of stuff. We\u0026rsquo;ll use in our sensor to create two more pseudo sensors to indicate wether the bed is occupied and/or full.\ngroup: bed_occupied: name: \u0026#34;Bed Occupied\u0026#34; entities: - binary_sensor.bed_occupancy_left - binary_sensor.bed_occupancy_right bed_full: name: \u0026#34;Bed Full\u0026#34; entities: - binary_sensor.bed_occupancy_left - binary_sensor.bed_occupancy_right all: true I usually also pair them with a Template binary_sensor to make them prettier:\nbinary_sensor: - platform: template sensors: # Bed Sensors bed_occupied: friendly_name: Bed Occupied (Master Bedroom) device_class: occupancy value_template: \u0026gt;- {{ is_state(\u0026#39;group.bed_occupied\u0026#39;, \u0026#39;on\u0026#39;) }} bed_full: friendly_name: Bed Full (Master Bedroom) device_class: occupancy value_template: \u0026gt;- {{ is_state(\u0026#39;group.bed_full\u0026#39;, \u0026#39;on\u0026#39;) }} Automate your bed Now that you can sense occupancy on you bed, you can go crazy with the automations. See below a curated list of my bed automations.\n Turn off all lights when bed_full Turn on the alarm at night when bed_full Turn off the alarm in the morning when not bed_full Turn on the lightstrips under the bed when (movement in front of the nightstand) when not bed_occupied (night lights) Disable Alexa voice notifications (input_boolean.voice_notifications) when bed_occupied  That\u0026rsquo;s all for today folks! If you have any questions or comments, please leave below!\n","permalink":"https://synapselabs.io/posts/bed-sensor-with-esphome-on-homeassistant/","tags":["Home Assistant","ESP8266","ESPHome","Sensors","HC-SR04"],"title":"Making a bed occupancy sensor with bathroom scales, ESP32, HX711 load-cell sensors and ESPHome on Home Assistant"},{"categories":["Home Automation"],"contents":"One of the things I like about the ESP family of micro-controllers is the amount of 3V3 and GND pins on the board. That allows us to use only dupont cables and saves us from the hassle (or if you\u0026rsquo;re terrible at soldering like me) of soldering stuff. This is an easy build, inspired by BRUH Automation\u0026rsquo;s $15 Multisensor but using ESPHome instead of custom code.\nI\u0026rsquo;ve spent lots of time building my own library for ESP sensors but when I gave ESPHome a try, I\u0026rsquo;ve immediately trashed all that code and migrated my all sensors into ESPHome. I never looked back and to date I\u0026rsquo;m 100% satisfied with that choice. It allows you to modify and deploy from Home Assistant\u0026rsquo;s ESPHome Add-On, handle unavailable states, have plenty of modules for different components and it\u0026rsquo;s just a breeze to use.\nWhat you\u0026rsquo;re gonna need  ESP8266 micro-controller DHT22 temperature \u0026amp; humidity sensor AM312 PIR motion sensor TEMT600 Analog Light Intensity Module 5mm Neopixel LED Some short dupont-cables. Optional: This 3D printed enclosure (requires 3D printer)  Note: I will not cover wiring up with the dupont cables as you can check this out on BRUH Automation\u0026rsquo;s video.\nTemperature \u0026amp; Humidity I left those at 60 seconds intervals, first because it\u0026rsquo;s a pretty acceptable update range for temperature sensing and second because DHT22s aren\u0026rsquo;t quite fond of being probed all the time. I also needed a lambda filter since the default output is in Celsius and I live in the United States and here we use freedom units, not the peasant metric system.\n- platform: dht pin: D6 model: AM2302 temperature: name: \u0026#34;Temperature (MultiSensor)\u0026#34; unit_of_measurement: \u0026#34;F\u0026#34; filters: - lambda: return x * (9.0/5.0) + 32.0;  Illuminance I check those every 2 seconds and use a sliding_window_moving_average filter to iron out outliers. Without a filter you will see this sensor bounce around. I\u0026rsquo;ve also used the lambda filter according to TEMT600\u0026rsquo;s cookbook on ESPHome website in order to convert the ADC input into illuminance lux values.\n- platform: adc pin: A0 name: \u0026#34;Illuminance (MultiSensor)\u0026#34; id: light_sensor unit_of_measurement: lux update_interval: 2s filters: - lambda: return (x * 3.3 / 10000.0) * 2000000.0; - sliding_window_moving_average: window_size: 5 send_every: 5 PIR Motion sensor This is the most straightforward, just defined as a binary_sensor. Couldn\u0026rsquo;t be more straightforward and so far I didn\u0026rsquo;t felt the need for filtering.\n- platform: gpio pin: D5 name: \u0026#34;Motion (MultiSensor)\u0026#34; device_class: motion Template sensor I use a template sensor to flip a binary_sensor called light whenever Illuminance crosses a given threshold (2 in my case). This is a useful feature if, for example, you want to only turn the lights on if the room is dark.\n- platform: template name: \u0026#34;Light (MultiSensor)\u0026#34; device_class: light lambda: |-if (id(light_sensor).state \u0026gt; 2) { return true; } else { return false; } Neopixel LED Having a Neopixel LED instead of a plain RGB led saves you some pins on the ESP8266 board and are exposed to Home Assistant as a light which you can control the color and brightness. I use with my automations in order to have a visual aid on the room occupancy status (OFF = clear, blue = occupied).\nlight: - platform: fastled_clockless chipset: WS2812 pin: D3 num_leds: 1 rgb_order: RGB name: \u0026#34;LED (MultiSensor)\u0026#34; Full code:\nesphome: name: multisensor platform: ESP8266 board: nodemcuv2 # adjust accordingly for your board wifi: ssid: \u0026#34;Your Wifi SSID\u0026#34; password: !secret wifi_password # Enable logging logger: # Enable Home Assistant API api: password: !secret api_password ota: password: !secret ota_password # Sensors sensor: - platform: dht pin: D6 model: AM2302 temperature: name: \u0026#34;Temperature (MultiSensor)\u0026#34; unit_of_measurement: \u0026#34;F\u0026#34; filters: - lambda: return x * (9.0/5.0) + 32.0;  humidity: name: \u0026#34;Humidity (MultiSensor)\u0026#34; update_interval: 60s - platform: adc pin: A0 name: \u0026#34;Illuminance (MultiSensor)\u0026#34; id: light_sensor unit_of_measurement: lux update_interval: 2s filters: - lambda: return (x * 3.3 / 10000.0) * 2000000.0; - sliding_window_moving_average: window_size: 5 send_every: 5 binary_sensor: - platform: gpio pin: D5 name: \u0026#34;Motion (MultiSensor)\u0026#34; device_class: motion - platform: template name: \u0026#34;Light (MultiSensor)\u0026#34; device_class: light lambda: |-if (id(light_sensor).state \u0026gt; 2) { return true; } else { return false; } light: - platform: fastled_clockless chipset: WS2812 pin: D3 num_leds: 1 rgb_order: RGB name: \u0026#34;LED (MultiSensor)\u0026#34; ","permalink":"https://synapselabs.io/posts/multisensors-with-esphome-on-homeassistant/","tags":["Home Assistant","ESP8266","ESPHome","Sensors","DHT22","AM312","TEMT6000","Neopixel","3D printing"],"title":"Building custom multisensors with an ESP8266 and ESPHome on Home Assistant"},{"categories":["Home Automation"],"contents":"If there\u0026rsquo;s one thing that makes everyone feels better despite having no friends, is having robots talking to you like they cared. From today on, every time you arrive home to your empty house because your partner divorced you and took your kids and your dog, you will feel that warmth in your heart.\nFor that, we\u0026rsquo;re gonna need the Better Presence Add-On for Home Assistant \u0026ndash; in order to know when we just arrived, a Door Sensor (I use Z-Wave Aeotec Door/Window Sensor 7) to know when we exactly open the front door and the Alexa Media Player custom component.\nWe will start by using the device_tracker sensor (created by Better Presence) as a trigger:\ntrigger: - platform: state entity_id: device_tracker.jseidl_presence to: \u0026#39;Just arrived\u0026#39; The wait_template action type in Home Assistant\u0026rsquo;s the script syntax (used in automations) enables us to wait until a sensor gets into a given state before giving up (timeout configurable) and we will use that to make our automation wait until the front door is open.\n- wait_template: \u0026#34;{{ is_state(\u0026#39;binary_sensor.door_main\u0026#39;, \u0026#39;on\u0026#39;) }}\u0026#34; timeout: \u0026#39;00:05:00\u0026#39; Finally, we use Alexa Media Player\u0026rsquo;s notify service endpoint to greet us:\n- service: notify.alexa_media_echo_dot_living_room data: data: type: announce message: \u0026#39;Welcome home Jan!\u0026#39; (Option #2) Use Google Assistant and Google Translate\u0026rsquo;s tts platform:\n- service: tts.google_translate_say entity_id: media_player.living_room_google_home data: message: \u0026#39;Welcome home Jan!\u0026#39; The full code:\nautomation: - alias: \u0026#39;Greets when Jan arrives (Alexa)\u0026#39; trigger: - platform: state entity_id: device_tracker.jseidl_presence to: \u0026#39;Just arrived\u0026#39; condition: - condition: state entity_id: input_boolean.voice_notifications state: \u0026#39;on\u0026#39; action: - wait_template: \u0026#34;{{ is_state(\u0026#39;binary_sensor.door_main\u0026#39;, \u0026#39;on\u0026#39;) }}\u0026#34; timeout: \u0026#39;00:05:00\u0026#39; - service: notify.alexa_media_echo_dot_living_room data: data: type: announce message: \u0026#39;Welcome home Jan!\u0026#39; That\u0026rsquo;s it! Hope that helps bringing a little more joy to your day!\n","permalink":"https://synapselabs.io/posts/using-alexa-to-greet-you-with-home-assistant/","tags":["Home Assistant","Alexa","Sensors"],"title":"Using Alexa to greet you with Home Assistant"},{"categories":null,"contents":"I\u0026rsquo;m a Brazilian information security warlock living in the US obssesed by robots!\n","permalink":"https://synapselabs.io/author/jan-seidl/","tags":null,"title":"Jan Seidl"}]